{"version":3,"file":"pristine.js","sources":["../src/lang.js","../src/utils.js","../src/pristine.js"],"sourcesContent":["export const lang = {\n  en: {\n    required: 'This field is required',\n    email: 'This field requires a valid e-mail address',\n    number: 'This field requires a number',\n    integer: 'This field requires an integer value',\n    url: 'This field requires a valid website URL',\n    tel: 'This field requires a valid telephone number',\n    maxlength: 'This fields length must be < ${1}',\n    minlength: 'This fields length must be > ${1}',\n    min: 'Minimum value for this field is ${1}',\n    max: 'Maximum value for this field is ${1}',\n    pattern: 'Please match the requested format',\n    equals: 'The two fields do not match',\n    default: 'Please enter a correct value',\n  },\n};\n","export function findAncestor(el, cls) {\n  while ((el = el.parentElement) && !el.classList.contains(cls));\n  return el;\n}\n\nexport function tmpl(str, ...args) {\n  if (typeof str !== 'string') return '';\n  const replacements = [...args].shift;\n  return str.replace(/\\${(\\d+)}/g, (match, index) => {\n    return replacements[parseInt(index)] !== undefined\n      ? replacements[parseInt(index)]\n      : match;\n  });\n}\n\nexport function groupedElemCount(input) {\n  return input.pristine.self.form.querySelectorAll(\n    'input[name=\"' + input.getAttribute('name') + '\"]:checked'\n  ).length;\n}\n\nexport function mergeConfig(obj1, obj2) {\n  for (let attr in obj2) {\n    if (!(attr in obj1)) {\n      obj1[attr] = obj2[attr];\n    }\n  }\n  return obj1;\n}\n","import { lang } from './lang';\nimport { tmpl, findAncestor, groupedElemCount } from './utils';\n\nlet defaultConfig = {\n  classTo: 'field',\n  errorClass: 'error',\n  successClass: 'success',\n  errorTextParent: 'field',\n  errorTextTag: 'div',\n  errorTextClass: 'error-msg',\n  liveAfterFirstValitation: true,\n};\n\nconst PRISTINE_ERROR = 'pristine-error';\n\nconst SELECTOR =\n  'input:not([disabled]):not([type^=hidden]):not([type^=submit]):not([type^=button]):not([data-pristine-ignore]), select, textarea';\n\nconst ALLOWED_ATTRIBUTES = [\n  'required',\n  'min',\n  'max',\n  'minlength',\n  'maxlength',\n  'pattern',\n];\n\nconst EMAIL_REGEX =\n  /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n\nconst MESSAGE_REGEX = /-message(?:-([a-z]{2}(?:_[A-Z]{2})?))?/; // matches, -message, -message-en, -message-en_US\nlet currentLocale = 'en';\nconst validators = {};\n\nconst _ = (name, validator) => {\n  validator.name = name;\n  if (validator.priority === undefined) validator.priority = 1;\n  validators[name] = validator;\n};\n\n_('text', { fn: (val, el) => true, priority: 0 });\n_('required', {\n  fn: (val, el) => {\n    return el.type === 'radio' || el.type === 'checkbox'\n      ? groupedElemCount(el)\n      : val !== undefined && val !== '';\n  },\n  priority: 99,\n  halt: true,\n});\n_('email', { fn: (val, el) => !val || EMAIL_REGEX.test(val) });\n_('number', { fn: (val, el) => !val || !isNaN(parseFloat(val)), priority: 2 });\n_('integer', { fn: (val, el) => !val || /^\\d+$/.test(val) });\n_('minlength', {\n  fn: (val, el, length) => !val || val.length >= parseInt(length),\n});\n_('maxlength', {\n  fn: (val, el, length) => !val || val.length <= parseInt(length),\n});\n_('min', {\n  fn: (val, el, limit) => {\n    return (\n      !val ||\n      (el.type === 'checkbox'\n        ? groupedElemCount(el) >= parseInt(limit)\n        : parseFloat(val) >= parseFloat(limit))\n    );\n  },\n});\n_('max', {\n  fn: (val, el, limit) => {\n    return (\n      !val ||\n      (el.type === 'checkbox'\n        ? groupedElemCount(el) <= parseInt(limit)\n        : parseFloat(val) <= parseFloat(limit))\n    );\n  },\n});\n_('pattern', {\n  fn: (val, el, pattern) => {\n    if (!val) return true;\n\n    // Check if pattern is already a regex pattern with slashes\n    let m =\n      typeof pattern === 'string'\n        ? pattern.match(new RegExp('^/(.*?)/([gimy]*)$'))\n        : null;\n\n    if (m) {\n      // It's a regex pattern with slashes, parse it\n      return new RegExp(m[1], m[2]).test(val);\n    } else {\n      // It's a regular pattern string, use it directly\n      return new RegExp(pattern).test(val);\n    }\n  },\n});\n_('equals', {\n  fn: (val, el, otherFieldSelector) => {\n    let other;\n\n    // Handle both selector strings and direct element references\n    if (\n      typeof otherFieldSelector === 'string' &&\n      otherFieldSelector.startsWith('#')\n    ) {\n      other = document.querySelector(otherFieldSelector);\n    } else if (otherFieldSelector instanceof HTMLElement) {\n      other = otherFieldSelector;\n    }\n\n    return other && ((!val && !other.value) || other.value === val);\n  },\n});\n\nexport default function Pristine(form, config, live = true) {\n  const self = this;\n  let wasValidated = false;\n\n  init(form, config, live);\n\n  function init(form, config, live) {\n    form.setAttribute('novalidate', 'true');\n\n    self.form = form;\n    self.config = { ...defaultConfig, ...(config || {}) };\n    self.live = !(live === false);\n\n    self.fields = Array.from(form.querySelectorAll(SELECTOR)).map((input) => {\n      const fns = [];\n      const params = {};\n      const messages = {};\n\n      Array.from(input.attributes).forEach((attr) => {\n        if (/^data-pristine-/.test(attr.name)) {\n          let name = attr.name.substr(14);\n          const messageMatch = name.match(MESSAGE_REGEX);\n          if (messageMatch !== null) {\n            const locale =\n              messageMatch[1] === undefined ? 'en' : messageMatch[1];\n            if (!messages.hasOwnProperty(locale)) messages[locale] = {};\n            messages[locale][\n              name.slice(0, name.length - messageMatch[0].length)\n            ] = attr.value;\n            return;\n          }\n          let attrValue = attr.value;\n          if (name === 'type') {\n            name = attrValue;\n          }\n          _addValidatorToField(fns, params, name, attrValue);\n        } else if (ALLOWED_ATTRIBUTES.includes(attr.name)) {\n          _addValidatorToField(fns, params, attr.name, attr.value);\n        } else if (attr.name === 'type') {\n          _addValidatorToField(fns, params, attr.value);\n        }\n      });\n\n      fns.sort((a, b) => b.priority - a.priority);\n\n      const listener = (e) => {\n        if (self.config.liveAfterFirstValitation && wasValidated) {\n          self.validate(e.target);\n        } else if (!self.config.liveAfterFirstValitation) {\n          self.validate(e.target);\n        }\n      };\n\n      if (self.live) {\n        input.addEventListener('change', listener);\n        if (!['radio', 'checkbox'].includes(input.getAttribute('type'))) {\n          input.addEventListener('input', listener);\n        }\n      }\n\n      return (input.pristine = {\n        input,\n        validators: fns,\n        params,\n        messages,\n        self,\n      });\n    });\n  }\n\n  function _addValidatorToField(fns, params, name, value) {\n    let validator = validators[name];\n    if (validator) {\n      fns.push(validator);\n      if (value) {\n        let valueParams;\n\n        // Case 1: Pattern - keep as is\n        if (name === 'pattern') {\n          valueParams = [value];\n        }\n        // Case 2: Check if it's valid JSON\n        else if (value.trim().startsWith('{') || value.trim().startsWith('[')) {\n          try {\n            // Try to parse as JSON\n            const jsonValue = JSON.parse(value);\n            valueParams = Array.isArray(jsonValue) ? jsonValue : [jsonValue];\n          } catch (e) {\n            // If JSON parsing fails, fall back to regular string\n            valueParams = value.split(',');\n          }\n        }\n        // Case 3: Regular string (comma-separated values)\n        else {\n          valueParams = value.split(',');\n        }\n\n        valueParams.unshift(null); // placeholder for input's value\n        params[name] = valueParams;\n      }\n    }\n  }\n\n  /***\n   * Checks whether the form/input elements are valid\n   * @param input => input element(s) or a jquery selector, null for full form validation\n   * @param silent => do not show error messages, just return true/false\n   * @returns {Promise<boolean>} returns a Promise that resolves to true when valid, false otherwise\n   */\n  self.validate = (input = null, silent = false) => {\n    let fields = self.fields;\n    if (input) {\n      if (input instanceof HTMLElement) {\n        fields = [input.pristine];\n      } else if (\n        input instanceof NodeList ||\n        input instanceof (window.$ || Array) ||\n        Array.isArray(input)\n      ) {\n        fields = Array.from(input).map((el) => el.pristine);\n      }\n    } else {\n      wasValidated = true;\n    }\n\n    let valid = true;\n    const promises = [];\n\n    for (let i = 0; fields[i]; i++) {\n      const field = fields[i];\n      const result = self.validateField(field);\n\n      // Check if validation returned a promise\n      if (result instanceof Promise) {\n        promises.push(\n          result.then((isValid) => {\n            if (isValid) {\n              !silent && _showSuccess(field);\n            } else {\n              valid = false;\n              !silent && _showError(field);\n            }\n            return isValid;\n          })\n        );\n      } else if (result) {\n        !silent && _showSuccess(field);\n      } else {\n        valid = false;\n        !silent && _showError(field);\n      }\n    }\n\n    // If we have async validators, wait for them to complete\n    if (promises.length > 0) {\n      return Promise.all(promises).then(() => valid);\n    }\n\n    // Otherwise return a resolved promise with the result\n    return Promise.resolve(valid);\n  };\n\n  /***\n   * Get errors of a specific field or the whole form\n   * @param input\n   * @returns {Array|*}\n   */\n  self.getErrors = function (input) {\n    if (!input) {\n      let erroneousFields = [];\n      for (let i = 0; i < self.fields.length; i++) {\n        let field = self.fields[i];\n        if (field.errors.length) {\n          erroneousFields.push({ input: field.input, errors: field.errors });\n        }\n      }\n      return erroneousFields;\n    }\n    if (input.tagName && input.tagName.toLowerCase() === 'select') {\n      return input.pristine.errors;\n    }\n    return input.length ? input[0].pristine.errors : input.pristine.errors;\n  };\n\n  /***\n   * Validates a single field, all validator functions are called and error messages are generated\n   * when a validator fails\n   * @param field\n   * @returns {boolean|Promise<boolean>} returns true/false for sync validation or a Promise for async validation\n   * @private\n   */\n  self.validateField = function (field) {\n    let errors = [];\n    let valid = true;\n    let promises = [];\n\n    for (let i = 0; field.validators[i]; i++) {\n      let validator = field.validators[i];\n      let params = field.params[validator.name]\n        ? [...field.params[validator.name]] // Create a copy of the parameters array\n        : [];\n      params[0] = field.input.value;\n\n      // Insert the element as the second parameter\n      if (params.length > 1) {\n        // Shift all parameters to make room for the element\n        params.splice(1, 0, field.input);\n      } else {\n        params.push(field.input);\n      }\n\n      let result = validator.fn.apply(null, params);\n\n      // Check if the validator returns a Promise\n      if (result instanceof Promise) {\n        // For async validators, add to promises array to handle later\n        promises.push(\n          result.then((isValid) => {\n            if (!isValid) {\n              valid = false;\n              let error = _getErrorMessage(field, validator, params);\n              errors.push(error);\n            }\n            return isValid;\n          })\n        );\n      } else if (!result) {\n        // For synchronous validators that fail\n        valid = false;\n        let error = _getErrorMessage(field, validator, params);\n        errors.push(error);\n\n        if (validator.halt === true) {\n          break;\n        }\n      }\n    }\n\n    // If we have async validators\n    if (promises.length > 0) {\n      // Return a promise that resolves when all validations are complete\n      return Promise.all(promises).then(() => {\n        field.errors = errors;\n        return valid && errors.length === 0;\n      });\n    }\n\n    // For synchronous validation only\n    field.errors = errors;\n    return valid;\n  };\n\n  // Helper function to get error message\n  function _getErrorMessage(field, validator, params) {\n    // Try to get the error message from various sources in order of priority\n    if (typeof validator.msg === 'function') {\n      return validator.msg(field.input.value, params, currentLocale);\n    }\n\n    if (\n      validator.msg === Object(validator.msg) &&\n      validator.msg[currentLocale]\n    ) {\n      return tmpl(validator.msg[currentLocale], ...params);\n    }\n\n    if (\n      field.messages[currentLocale] &&\n      field.messages[currentLocale][validator.name]\n    ) {\n      return tmpl(field.messages[currentLocale][validator.name], ...params);\n    }\n\n    if (lang[currentLocale] && lang[currentLocale][validator.name]) {\n      return tmpl(lang[currentLocale][validator.name], ...params);\n    }\n\n    if (typeof validator.msg === 'string') {\n      return tmpl(validator.msg, ...params);\n    }\n    // If no specific message is found, use the default message or a fallback\n    if (lang[currentLocale] && lang[currentLocale].default) {\n      return tmpl(lang[currentLocale].default, ...params);\n    }\n\n    // Ensure we always return a non-empty string\n    return `Validation failed for ${validator.name}`;\n  }\n\n  /***\n   * Add a validator to a specific dom element in a form\n   * @param elem => The dom element where the validator is applied to\n   * @param fn => validator function\n   * @param msg => message to show when validation fails. Supports templating. ${0} for the input's value, ${1} and\n   * so on are for the attribute values\n   * @param priority => priority of the validator function, higher valued function gets called first.\n   * @param halt => whether validation should stop for this field after current validation function\n   */\n  self.addValidator = function (elem, fn, msg, priority, halt) {\n    if (elem instanceof HTMLElement) {\n      elem.pristine.validators.push({ fn, msg, priority, halt });\n      elem.pristine.validators.sort((a, b) => b.priority - a.priority);\n    } else {\n      console.warn('The parameter elem must be a dom element');\n    }\n  };\n\n  /***\n   * An utility function that returns a 2-element array, first one is the element where error/success class is\n   * applied. 2nd one is the element where error message is displayed. 2nd element is created if doesn't exist and cached.\n   * @param field\n   * @returns {*}\n   * @private\n   */\n  function _getErrorElements(field) {\n    if (field.errorElements) {\n      return field.errorElements;\n    }\n    let errorClassElement = findAncestor(field.input, self.config.classTo);\n    let errorTextParent = null,\n      errorTextElement = null;\n    if (self.config.classTo === self.config.errorTextParent) {\n      errorTextParent = errorClassElement;\n    } else {\n      if (!errorClassElement) return [null, null];\n      errorTextParent = errorClassElement.querySelector(\n        '.' + self.config.errorTextParent\n      );\n    }\n    if (errorTextParent) {\n      errorTextElement = errorTextParent.querySelector('.' + PRISTINE_ERROR);\n      if (!errorTextElement) {\n        errorTextElement = document.createElement(self.config.errorTextTag);\n        errorTextElement.className =\n          PRISTINE_ERROR + ' ' + self.config.errorTextClass;\n        errorTextParent.appendChild(errorTextElement);\n        errorTextElement.pristineDisplay = errorTextElement.style.display;\n      }\n    }\n    return (field.errorElements = [errorClassElement, errorTextElement]);\n  }\n\n  function _showError(field) {\n    let errorElements = _getErrorElements(field);\n    let errorClassElement = errorElements[0],\n      errorTextElement = errorElements[1];\n\n    if (errorClassElement) {\n      errorClassElement.classList.remove(self.config.successClass);\n      errorClassElement.classList.add(self.config.errorClass);\n    }\n    if (errorTextElement) {\n      errorTextElement.innerHTML = field.errors.join('<br/>');\n      errorTextElement.style.display = errorTextElement.pristineDisplay || '';\n    }\n  }\n\n  /***\n   * Adds error to a specific field\n   * @param input\n   * @param error\n   */\n  self.addError = function (input, error) {\n    input = input.length ? input[0] : input;\n    input.pristine.errors.push(error);\n    _showError(input.pristine);\n  };\n\n  self.removeError = function (field) {\n    let errorElements = _getErrorElements(field);\n    let errorClassElement = errorElements[0],\n      errorTextElement = errorElements[1];\n    if (errorClassElement) {\n      // IE > 9 doesn't support multiple class removal\n      errorClassElement.classList.remove(self.config.errorClass);\n      errorClassElement.classList.remove(self.config.successClass);\n    }\n    if (errorTextElement) {\n      errorTextElement.innerHTML = '';\n      errorTextElement.style.display = 'none';\n    }\n    return errorElements;\n  };\n\n  function _showSuccess(field) {\n    let errorClassElement = self.removeError(field)[0];\n    errorClassElement &&\n      errorClassElement.classList.add(self.config.successClass);\n  }\n\n  /***\n   * Resets the errors\n   */\n  self.reset = function () {\n    for (let i = 0; self.fields[i]; i++) {\n      self.fields[i].errorElements = null;\n    }\n    Array.from(self.form.querySelectorAll('.' + PRISTINE_ERROR)).map(function (\n      elem\n    ) {\n      elem.parentNode.removeChild(elem);\n    });\n    Array.from(self.form.querySelectorAll('.' + self.config.classTo)).map(\n      function (elem) {\n        elem.classList.remove(self.config.successClass);\n        elem.classList.remove(self.config.errorClass);\n      }\n    );\n  };\n\n  /***\n   * Resets the errors and deletes all pristine fields\n   */\n  self.destroy = function () {\n    self.reset();\n    self.fields.forEach(function (field) {\n      delete field.input.pristine;\n    });\n    self.fields = [];\n  };\n\n  self.setGlobalConfig = function (config) {\n    defaultConfig = config;\n  };\n\n  return self;\n}\n\n/***\n *\n * @param name => Name of the global validator\n * @param fn => validator function\n * @param msg => message to show when validation fails. Supports templating. ${0} for the input's value, ${1} and\n * so on are for the attribute values\n * @param priority => priority of the validator function, higher valued function gets called first.\n * @param halt => whether validation should stop for this field after current validation function\n */\nPristine.addValidator = function (name, fn, msg, priority, halt) {\n  _(name, { fn, msg, priority, halt });\n};\n\nPristine.addMessages = function (locale, messages) {\n  let langObj = lang.hasOwnProperty(locale)\n    ? lang[locale]\n    : (lang[locale] = {});\n\n  Object.keys(messages).forEach(function (key, index) {\n    langObj[key] = messages[key];\n  });\n};\n\nPristine.setLocale = function (locale) {\n  currentLocale = locale;\n};\n"],"names":["lang","findAncestor","el","cls","tmpl","str","args","replacements","match","index","groupedElemCount","input","defaultConfig","PRISTINE_ERROR","SELECTOR","ALLOWED_ATTRIBUTES","EMAIL_REGEX","MESSAGE_REGEX","currentLocale","validators","_","name","validator","val","length","limit","pattern","m","otherFieldSelector","other","Pristine","form","config","live","self","wasValidated","init","fns","params","messages","attr","messageMatch","locale","attrValue","_addValidatorToField","a","b","listener","e","value","valueParams","jsonValue","silent","fields","valid","promises","i","field","result","isValid","_showSuccess","_showError","erroneousFields","errors","error","_getErrorMessage","elem","fn","msg","priority","halt","_getErrorElements","errorClassElement","errorTextParent","errorTextElement","errorElements","langObj","key"],"mappings":"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"}