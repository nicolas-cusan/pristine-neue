{"version":3,"file":"pristine.umd.cjs","sources":["../src/lang.js","../src/utils.js","../src/pristine.js"],"sourcesContent":["export const lang = {\n  en: {\n    required: 'This field is required',\n    email: 'This field requires a valid e-mail address',\n    number: 'This field requires a number',\n    integer: 'This field requires an integer value',\n    url: 'This field requires a valid website URL',\n    tel: 'This field requires a valid telephone number',\n    maxlength: 'This fields length must be < ${1}',\n    minlength: 'This fields length must be > ${1}',\n    min: 'Minimum value for this field is ${1}',\n    max: 'Maximum value for this field is ${1}',\n    pattern: 'Please match the requested format',\n    equals: 'The two fields do not match',\n    default: 'Please enter a correct value',\n  },\n};\n","export function findAncestor(el, cls) {\n  while ((el = el.parentElement) && !el.classList.contains(cls));\n  return el;\n}\n\nexport function tmpl(str, ...args) {\n  if (typeof str !== 'string') return '';\n  const replacements = [...args].shift;\n  return str.replace(/\\${(\\d+)}/g, (match, index) => {\n    return replacements[parseInt(index)] !== undefined\n      ? replacements[parseInt(index)]\n      : match;\n  });\n}\n\nexport function groupedElemCount(input) {\n  return input.pristine.self.form.querySelectorAll(\n    'input[name=\"' + input.getAttribute('name') + '\"]:checked'\n  ).length;\n}\n\nexport function mergeConfig(obj1, obj2) {\n  for (let attr in obj2) {\n    if (!(attr in obj1)) {\n      obj1[attr] = obj2[attr];\n    }\n  }\n  return obj1;\n}\n","import { lang } from './lang';\nimport { tmpl, findAncestor, groupedElemCount } from './utils';\n\nlet defaultConfig = {\n  classTo: 'field',\n  errorClass: 'error',\n  successClass: 'success',\n  errorTextParent: 'field',\n  errorTextTag: 'div',\n  errorTextClass: 'error-msg',\n  liveAfterFirstValitation: true,\n};\n\nconst PRISTINE_ERROR = 'pristine-error';\n\nconst SELECTOR =\n  'input:not([disabled]):not([type^=hidden]):not([type^=submit]):not([type^=button]):not([data-pristine-ignore]), select, textarea';\n\nconst ALLOWED_ATTRIBUTES = [\n  'required',\n  'min',\n  'max',\n  'minlength',\n  'maxlength',\n  'pattern',\n];\n\nconst EMAIL_REGEX =\n  /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n\nconst MESSAGE_REGEX = /-message(?:-([a-z]{2}(?:_[A-Z]{2})?))?/; // matches, -message, -message-en, -message-en_US\nlet currentLocale = 'en';\nconst validators = {};\n\nconst _ = (name, validator) => {\n  validator.name = name;\n  if (validator.priority === undefined) validator.priority = 1;\n  validators[name] = validator;\n};\n\n_('text', { fn: (val, el) => true, priority: 0 });\n_('required', {\n  fn: (val, el) => {\n    return el.type === 'radio' || el.type === 'checkbox'\n      ? groupedElemCount(el)\n      : val !== undefined && val !== '';\n  },\n  priority: 99,\n  halt: true,\n});\n_('email', { fn: (val, el) => !val || EMAIL_REGEX.test(val) });\n_('number', { fn: (val, el) => !val || !isNaN(parseFloat(val)), priority: 2 });\n_('integer', { fn: (val, el) => !val || /^\\d+$/.test(val) });\n_('minlength', {\n  fn: (val, el, length) => !val || val.length >= parseInt(length),\n});\n_('maxlength', {\n  fn: (val, el, length) => !val || val.length <= parseInt(length),\n});\n_('min', {\n  fn: (val, el, limit) => {\n    return (\n      !val ||\n      (el.type === 'checkbox'\n        ? groupedElemCount(el) >= parseInt(limit)\n        : parseFloat(val) >= parseFloat(limit))\n    );\n  },\n});\n_('max', {\n  fn: (val, el, limit) => {\n    return (\n      !val ||\n      (el.type === 'checkbox'\n        ? groupedElemCount(el) <= parseInt(limit)\n        : parseFloat(val) <= parseFloat(limit))\n    );\n  },\n});\n_('pattern', {\n  fn: (val, el, pattern) => {\n    if (!val) return true;\n\n    // Check if pattern is already a regex pattern with slashes\n    let m =\n      typeof pattern === 'string'\n        ? pattern.match(new RegExp('^/(.*?)/([gimy]*)$'))\n        : null;\n\n    if (m) {\n      // It's a regex pattern with slashes, parse it\n      return new RegExp(m[1], m[2]).test(val);\n    } else {\n      // It's a regular pattern string, use it directly\n      return new RegExp(pattern).test(val);\n    }\n  },\n});\n_('equals', {\n  fn: (val, el, otherFieldSelector) => {\n    let other;\n\n    // Handle both selector strings and direct element references\n    if (\n      typeof otherFieldSelector === 'string' &&\n      otherFieldSelector.startsWith('#')\n    ) {\n      other = document.querySelector(otherFieldSelector);\n    } else if (otherFieldSelector instanceof HTMLElement) {\n      other = otherFieldSelector;\n    }\n\n    return other && ((!val && !other.value) || other.value === val);\n  },\n});\n\nexport default function Pristine(form, config, live = true) {\n  const self = this;\n  let wasValidated = false;\n\n  init(form, config, live);\n\n  function init(form, config, live) {\n    form.setAttribute('novalidate', 'true');\n\n    self.form = form;\n    self.config = { ...defaultConfig, ...(config || {}) };\n    self.live = !(live === false);\n\n    self.fields = Array.from(form.querySelectorAll(SELECTOR)).map((input) => {\n      const fns = [];\n      const params = {};\n      const messages = {};\n\n      Array.from(input.attributes).forEach((attr) => {\n        if (/^data-pristine-/.test(attr.name)) {\n          let name = attr.name.substr(14);\n          const messageMatch = name.match(MESSAGE_REGEX);\n          if (messageMatch !== null) {\n            const locale =\n              messageMatch[1] === undefined ? 'en' : messageMatch[1];\n            if (!messages.hasOwnProperty(locale)) messages[locale] = {};\n            messages[locale][\n              name.slice(0, name.length - messageMatch[0].length)\n            ] = attr.value;\n            return;\n          }\n          let attrValue = attr.value;\n          if (name === 'type') {\n            name = attrValue;\n          }\n          _addValidatorToField(fns, params, name, attrValue);\n        } else if (ALLOWED_ATTRIBUTES.includes(attr.name)) {\n          _addValidatorToField(fns, params, attr.name, attr.value);\n        } else if (attr.name === 'type') {\n          _addValidatorToField(fns, params, attr.value);\n        }\n      });\n\n      fns.sort((a, b) => b.priority - a.priority);\n\n      const listener = (e) => {\n        if (self.config.liveAfterFirstValitation && wasValidated) {\n          self.validate(e.target);\n        } else if (!self.config.liveAfterFirstValitation) {\n          self.validate(e.target);\n        }\n      };\n\n      if (self.live) {\n        input.addEventListener('change', listener);\n        if (!['radio', 'checkbox'].includes(input.getAttribute('type'))) {\n          input.addEventListener('input', listener);\n        }\n      }\n\n      return (input.pristine = {\n        input,\n        validators: fns,\n        params,\n        messages,\n        self,\n      });\n    });\n  }\n\n  function _addValidatorToField(fns, params, name, value) {\n    let validator = validators[name];\n    if (validator) {\n      fns.push(validator);\n      if (value) {\n        let valueParams;\n\n        // Case 1: Pattern - keep as is\n        if (name === 'pattern') {\n          valueParams = [value];\n        }\n        // Case 2: Check if it's valid JSON\n        else if (value.trim().startsWith('{') || value.trim().startsWith('[')) {\n          try {\n            // Try to parse as JSON\n            const jsonValue = JSON.parse(value);\n            valueParams = Array.isArray(jsonValue) ? jsonValue : [jsonValue];\n          } catch (e) {\n            // If JSON parsing fails, fall back to regular string\n            valueParams = value.split(',');\n          }\n        }\n        // Case 3: Regular string (comma-separated values)\n        else {\n          valueParams = value.split(',');\n        }\n\n        valueParams.unshift(null); // placeholder for input's value\n        params[name] = valueParams;\n      }\n    }\n  }\n\n  /***\n   * Checks whether the form/input elements are valid\n   * @param input => input element(s) or a jquery selector, null for full form validation\n   * @param silent => do not show error messages, just return true/false\n   * @returns {Promise<boolean>} returns a Promise that resolves to true when valid, false otherwise\n   */\n  self.validate = (input = null, silent = false) => {\n    let fields = self.fields;\n    if (input) {\n      if (input instanceof HTMLElement) {\n        fields = [input.pristine];\n      } else if (\n        input instanceof NodeList ||\n        input instanceof (window.$ || Array) ||\n        Array.isArray(input)\n      ) {\n        fields = Array.from(input).map((el) => el.pristine);\n      }\n    } else {\n      wasValidated = true;\n    }\n\n    let valid = true;\n    const promises = [];\n\n    for (let i = 0; fields[i]; i++) {\n      const field = fields[i];\n      const result = self.validateField(field);\n\n      // Check if validation returned a promise\n      if (result instanceof Promise) {\n        promises.push(\n          result.then((isValid) => {\n            if (isValid) {\n              !silent && _showSuccess(field);\n            } else {\n              valid = false;\n              !silent && _showError(field);\n            }\n            return isValid;\n          })\n        );\n      } else if (result) {\n        !silent && _showSuccess(field);\n      } else {\n        valid = false;\n        !silent && _showError(field);\n      }\n    }\n\n    // If we have async validators, wait for them to complete\n    if (promises.length > 0) {\n      return Promise.all(promises).then(() => valid);\n    }\n\n    // Otherwise return a resolved promise with the result\n    return Promise.resolve(valid);\n  };\n\n  /***\n   * Get errors of a specific field or the whole form\n   * @param input\n   * @returns {Array|*}\n   */\n  self.getErrors = function (input) {\n    if (!input) {\n      let erroneousFields = [];\n      for (let i = 0; i < self.fields.length; i++) {\n        let field = self.fields[i];\n        if (field.errors.length) {\n          erroneousFields.push({ input: field.input, errors: field.errors });\n        }\n      }\n      return erroneousFields;\n    }\n    if (input.tagName && input.tagName.toLowerCase() === 'select') {\n      return input.pristine.errors;\n    }\n    return input.length ? input[0].pristine.errors : input.pristine.errors;\n  };\n\n  /***\n   * Validates a single field, all validator functions are called and error messages are generated\n   * when a validator fails\n   * @param field\n   * @returns {boolean|Promise<boolean>} returns true/false for sync validation or a Promise for async validation\n   * @private\n   */\n  self.validateField = function (field) {\n    let errors = [];\n    let valid = true;\n    let promises = [];\n\n    for (let i = 0; field.validators[i]; i++) {\n      let validator = field.validators[i];\n      let params = field.params[validator.name]\n        ? [...field.params[validator.name]] // Create a copy of the parameters array\n        : [];\n      params[0] = field.input.value;\n\n      // Insert the element as the second parameter\n      if (params.length > 1) {\n        // Shift all parameters to make room for the element\n        params.splice(1, 0, field.input);\n      } else {\n        params.push(field.input);\n      }\n\n      let result = validator.fn.apply(null, params);\n\n      // Check if the validator returns a Promise\n      if (result instanceof Promise) {\n        // For async validators, add to promises array to handle later\n        promises.push(\n          result.then((isValid) => {\n            if (!isValid) {\n              valid = false;\n              let error = _getErrorMessage(field, validator, params);\n              errors.push(error);\n            }\n            return isValid;\n          })\n        );\n      } else if (!result) {\n        // For synchronous validators that fail\n        valid = false;\n        let error = _getErrorMessage(field, validator, params);\n        errors.push(error);\n\n        if (validator.halt === true) {\n          break;\n        }\n      }\n    }\n\n    // If we have async validators\n    if (promises.length > 0) {\n      // Return a promise that resolves when all validations are complete\n      return Promise.all(promises).then(() => {\n        field.errors = errors;\n        return valid && errors.length === 0;\n      });\n    }\n\n    // For synchronous validation only\n    field.errors = errors;\n    return valid;\n  };\n\n  // Helper function to get error message\n  function _getErrorMessage(field, validator, params) {\n    let errorMessage = null;\n\n    // Try to get the error message from various sources in order of priority\n    if (typeof validator.msg === 'function') {\n      errorMessage = validator.msg(field.input.value, params);\n    } else if (typeof validator.msg === 'string') {\n      errorMessage = tmpl(validator.msg, ...params);\n    } else if (\n      validator.msg === Object(validator.msg) &&\n      validator.msg[currentLocale]\n    ) {\n      errorMessage = tmpl(validator.msg[currentLocale], ...params);\n    } else if (\n      field.messages[currentLocale] &&\n      field.messages[currentLocale][validator.name]\n    ) {\n      errorMessage = tmpl(\n        field.messages[currentLocale][validator.name],\n        ...params\n      );\n    } else if (lang[currentLocale] && lang[currentLocale][validator.name]) {\n      errorMessage = tmpl(lang[currentLocale][validator.name], ...params);\n    } else {\n      // If no specific message is found, use the default message or a fallback\n      if (lang[currentLocale] && lang[currentLocale].default) {\n        errorMessage = tmpl(lang[currentLocale].default, ...params);\n      } else {\n        errorMessage = `Validation failed for ${validator.name}`;\n      }\n    }\n\n    // Ensure we always return a non-empty string\n    if (!errorMessage || errorMessage.trim() === '') {\n      return `Validation failed for ${validator.name}`;\n    }\n\n    return errorMessage;\n  }\n\n  /***\n   * Add a validator to a specific dom element in a form\n   * @param elem => The dom element where the validator is applied to\n   * @param fn => validator function\n   * @param msg => message to show when validation fails. Supports templating. ${0} for the input's value, ${1} and\n   * so on are for the attribute values\n   * @param priority => priority of the validator function, higher valued function gets called first.\n   * @param halt => whether validation should stop for this field after current validation function\n   */\n  self.addValidator = function (elem, fn, msg, priority, halt) {\n    if (elem instanceof HTMLElement) {\n      elem.pristine.validators.push({ fn, msg, priority, halt });\n      elem.pristine.validators.sort((a, b) => b.priority - a.priority);\n    } else {\n      console.warn('The parameter elem must be a dom element');\n    }\n  };\n\n  /***\n   * An utility function that returns a 2-element array, first one is the element where error/success class is\n   * applied. 2nd one is the element where error message is displayed. 2nd element is created if doesn't exist and cached.\n   * @param field\n   * @returns {*}\n   * @private\n   */\n  function _getErrorElements(field) {\n    if (field.errorElements) {\n      return field.errorElements;\n    }\n    let errorClassElement = findAncestor(field.input, self.config.classTo);\n    let errorTextParent = null,\n      errorTextElement = null;\n    if (self.config.classTo === self.config.errorTextParent) {\n      errorTextParent = errorClassElement;\n    } else {\n      if (!errorClassElement) return [null, null];\n      errorTextParent = errorClassElement.querySelector(\n        '.' + self.config.errorTextParent\n      );\n    }\n    if (errorTextParent) {\n      errorTextElement = errorTextParent.querySelector('.' + PRISTINE_ERROR);\n      if (!errorTextElement) {\n        errorTextElement = document.createElement(self.config.errorTextTag);\n        errorTextElement.className =\n          PRISTINE_ERROR + ' ' + self.config.errorTextClass;\n        errorTextParent.appendChild(errorTextElement);\n        errorTextElement.pristineDisplay = errorTextElement.style.display;\n      }\n    }\n    return (field.errorElements = [errorClassElement, errorTextElement]);\n  }\n\n  function _showError(field) {\n    let errorElements = _getErrorElements(field);\n    let errorClassElement = errorElements[0],\n      errorTextElement = errorElements[1];\n\n    if (errorClassElement) {\n      errorClassElement.classList.remove(self.config.successClass);\n      errorClassElement.classList.add(self.config.errorClass);\n    }\n    if (errorTextElement) {\n      errorTextElement.innerHTML = field.errors.join('<br/>');\n      errorTextElement.style.display = errorTextElement.pristineDisplay || '';\n    }\n  }\n\n  /***\n   * Adds error to a specific field\n   * @param input\n   * @param error\n   */\n  self.addError = function (input, error) {\n    input = input.length ? input[0] : input;\n    input.pristine.errors.push(error);\n    _showError(input.pristine);\n  };\n\n  self.removeError = function (field) {\n    let errorElements = _getErrorElements(field);\n    let errorClassElement = errorElements[0],\n      errorTextElement = errorElements[1];\n    if (errorClassElement) {\n      // IE > 9 doesn't support multiple class removal\n      errorClassElement.classList.remove(self.config.errorClass);\n      errorClassElement.classList.remove(self.config.successClass);\n    }\n    if (errorTextElement) {\n      errorTextElement.innerHTML = '';\n      errorTextElement.style.display = 'none';\n    }\n    return errorElements;\n  };\n\n  function _showSuccess(field) {\n    let errorClassElement = self.removeError(field)[0];\n    errorClassElement &&\n      errorClassElement.classList.add(self.config.successClass);\n  }\n\n  /***\n   * Resets the errors\n   */\n  self.reset = function () {\n    for (let i = 0; self.fields[i]; i++) {\n      self.fields[i].errorElements = null;\n    }\n    Array.from(self.form.querySelectorAll('.' + PRISTINE_ERROR)).map(function (\n      elem\n    ) {\n      elem.parentNode.removeChild(elem);\n    });\n    Array.from(self.form.querySelectorAll('.' + self.config.classTo)).map(\n      function (elem) {\n        elem.classList.remove(self.config.successClass);\n        elem.classList.remove(self.config.errorClass);\n      }\n    );\n  };\n\n  /***\n   * Resets the errors and deletes all pristine fields\n   */\n  self.destroy = function () {\n    self.reset();\n    self.fields.forEach(function (field) {\n      delete field.input.pristine;\n    });\n    self.fields = [];\n  };\n\n  self.setGlobalConfig = function (config) {\n    defaultConfig = config;\n  };\n\n  return self;\n}\n\n/***\n *\n * @param name => Name of the global validator\n * @param fn => validator function\n * @param msg => message to show when validation fails. Supports templating. ${0} for the input's value, ${1} and\n * so on are for the attribute values\n * @param priority => priority of the validator function, higher valued function gets called first.\n * @param halt => whether validation should stop for this field after current validation function\n */\nPristine.addValidator = function (name, fn, msg, priority, halt) {\n  _(name, { fn, msg, priority, halt });\n};\n\nPristine.addMessages = function (locale, messages) {\n  let langObj = lang.hasOwnProperty(locale)\n    ? lang[locale]\n    : (lang[locale] = {});\n\n  Object.keys(messages).forEach(function (key, index) {\n    langObj[key] = messages[key];\n  });\n};\n\nPristine.setLocale = function (locale) {\n  currentLocale = locale;\n};\n"],"names":["lang","findAncestor","el","cls","tmpl","str","args","replacements","match","index","groupedElemCount","input","defaultConfig","PRISTINE_ERROR","SELECTOR","ALLOWED_ATTRIBUTES","EMAIL_REGEX","MESSAGE_REGEX","currentLocale","validators","_","name","validator","val","length","limit","pattern","m","otherFieldSelector","other","Pristine","form","config","live","self","wasValidated","init","fns","params","messages","attr","messageMatch","locale","attrValue","_addValidatorToField","a","b","listener","e","value","valueParams","jsonValue","silent","fields","valid","promises","i","field","result","isValid","_showSuccess","_showError","erroneousFields","errors","error","_getErrorMessage","errorMessage","elem","fn","msg","priority","halt","_getErrorElements","errorClassElement","errorTextParent","errorTextElement","errorElements","langObj","key"],"mappings":"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"}